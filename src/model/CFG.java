package model;

import java.util.*;

/**Represent a Context-Free Grammar
 * @author ALEX JR (ALEXJR2002)
 * @version 1.0
 * @since 1.0
 */

public class CFG {

    private char[] variables;
    private char[] symbols;
    private char initialSymbol;
    private HashMap<Character, String> productions;
    char [][] cykTable;

    /** Creates a Context-Free Grammar with the specified variables, symbols and initialVariable
     * @param inputVariables the cfg variables
     * @param inputSymbols the cfg symbols
     * @param inputInitialSymbol the cfg initial variable
     */
    public CFG(String inputVariables, String inputSymbols, char inputInitialSymbol) {
        variables = inputVariables.toCharArray();
        symbols = inputSymbols.toCharArray();
        initialSymbol = inputInitialSymbol;
    }

    /**Return the variables array
     * @return the variables in a character array
     */
    public char [] getVariables() {
        return variables;
    }

    /**Changes the variable array by a new char array
     * @param variables representing a new character array
     */
    public void setVariables(char [] variables) {
        this.variables = variables;
    }

    /** Gets the array of symbols
     * @return the symbols in a character array
     */
    public char [] getSymbols() {
        return symbols;
    }

    /** Changes the symbols array by a new char array
     * @param symbols representing a new character array
     */
    public void setSymbols(char [] symbols) {
        this.symbols = symbols;
    }

    /** Gets the Context-Free Grammar initial symbol
     * @return the CFG initial symbol
     */
    public char getInitialSymbol() {
        return initialSymbol;
    }

    /** Changes the initial symbol by a new one
     * @param initialSymbol representing a new character initial symbol
     */
    public void setInitialSymbol(char initialSymbol) {
        this.initialSymbol = initialSymbol;
    }

    /** Gets the productions per variable
     * @return each variable with its productions
     */
    public HashMap<Character, String> getProductions() {
        return productions;
    }

    /** Changes the grammar productions
     * @param productions new productions in a HashMap form
     */
    public void setProductions(HashMap<Character, String> productions) {
        this.productions = productions;
    }

    /** Gets the CYK Table 
     * @return CYK Table
     */
    public char[][] getCykTable() {
        return cykTable;
    }


    /** Checks if a string is achieved by the grammar
     * @param w a string with the correct format
     * @return true if the string is generated by the grammar, false otherwise
     */
    public boolean cykAlgorithm (String w) {
        initializeTable(w);
        int n = w.length();
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < n - j; i++) {
                for (int k = 0; k < j; k++){
                    String productionToSearch = "" + cykTable[i][k] + cykTable[i + k + 1][j - k - 1];
                    for (char key : productions.keySet()) {
                        if (productions.get(key).contains(productionToSearch)) {
                            cykTable[i][j] = key;
                            break;
                        }
                    }
                }
            }
        }
        return cykTable[0][n - 1] == initialSymbol;
    }

    /** Checks if the grammar is in Chomsky Normal Form
     * @return true if is in Chomsky Normal Form, false otherwise
     */
    public boolean isCNF () {
        return hasBinaryOrSimpleProductions() && reachableVariables() && terminableVariables() && !hasLambdaProductions();
    }

    /** Checks if the grammar has binary and/or simple productions.
     * @return true if the grammar has binary and/or simple productions, false otherwise.
     */
    private boolean hasBinaryOrSimpleProductions () {
        for (String production : productions.values()) {
            String [] productionsArray = production.split("\\|");
            for (String s : productionsArray) {
                if (s.length() > 2) {
                    return false;
                }else if (s.length() == 2 && s.equals(s.toUpperCase())) {
                    break;
                }else if (s.length() == 1 && s.equals(s.toLowerCase())) {
                    break;
                }else {
                    return false;
                }
            }
        }
        return true;
    }

    /** Checks if the grammar has reachable variables.
     * @return true if all variables are reachable, false otherwise
     */
    private boolean reachableVariables () {
        ArrayList<Character> unreachableVariables = toCharacterArrayList();
        for (Character variable : productions.keySet()) {
            for (String production : productions.values()){
                if (!productions.get(variable).equals(production)) {
                    if (production.contains("" + variable)) {
                        if (unreachableVariables.remove(variable))
                        break;
                    }
                }
            }
        }
        return unreachableVariables.isEmpty();
    }

    /** Checks if the grammar has terminable variables
     * @return true if all variables are terminable, false otherwise.
     */
    private boolean terminableVariables () {
        ArrayList<Character> generating = new ArrayList<>();
        ArrayList<Character> variableArrayList = toCharacterArrayList();
        variableArrayList.add(initialSymbol);
        for (Character variable : productions.keySet()) {
            String [] production = productions.get(variable).split("\\|");
            for (String s : production) {
                if (s.equals(s.toLowerCase())) {
                    generating.add(variable);
                    break;
                }
            }
        }
        for (Character variable : variableArrayList) {
            for (Character generatingVariable : generating) {
                if (productions.get(variable).contains("" + generatingVariable) && !generating.contains(variable)) {
                    generating.add(variable);
                    break;
                }
            }
        }
        return generating.size() == variables.length;
    }

    /** Checks if the grammar has lambda productions not allowed by Chomsky Normal Form.
     * @return true if the grammar
     */
    private boolean hasLambdaProductions () {
        String initialProduction = productions.get(initialSymbol);
        for (String production : productions.values()) {
            if (production.contains("Î»") && production.length() > 1 && !production.equals(initialProduction)) {
                return true;
            }
        }
        return false;
    }

    /** Converts the variables array to Character ArrayList
     * @return a character arraylist
     */
    private ArrayList<Character> toCharacterArrayList () {
        ArrayList<Character> charactersArrayList = new ArrayList<>();
        for (char variable : variables) {
            if (variable != initialSymbol)
                charactersArrayList.add(variable);
        }
        return charactersArrayList;
    }

    /** Fill the first column of the CYK table
     * @param w the string which will be used to size the table.
     */
    private void initializeTable (String w) {
        cykTable  = new char[w.length()][w.length()];
        //Fill the first column
        for (int i = 0; i < w.length(); i++) {
            for (char key : productions.keySet()){
                if (productions.get(key).contains("" + w.charAt(i))) {
                    cykTable[i][0] = key;
                    break;
                }
            }
        }
    }

    /** Show the CYK table in text format
     * @return CYK table as string
     */
    public String cykTableToString () {
        String message = "";
        for (int i = 0; i < cykTable.length; i++) {
            for (int j = 0; j < cykTable[i].length; j++) {
                message += cykTable[i][j];
            }
            message += "\n";
        }
        return message;
    }
}
